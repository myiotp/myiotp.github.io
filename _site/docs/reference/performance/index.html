

<!Doctype html>
<html id="docs" class="Reference Documentation">



<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Thingsboard Data Collection Performance - Thingsboard</title>
<meta property="og:title" content="Thingsboard Data Collection Performance" />
<meta name="description" content="Thingsboard IoT Platform data collection performance overview" />
<meta property="og:description" content="Thingsboard IoT Platform data collection performance overview" />
<link rel="canonical" href="http://localhost:4000/docs/reference/performance/" />
<meta property="og:url" content="http://localhost:4000/docs/reference/performance/" />
<meta property="og:site_name" content="Thingsboard" />
<meta property="og:image" content="http://localhost:4000/images/thingsboard_logo.png" />
<meta name="twitter:image" content="http://localhost:4000/images/thingsboard_logo.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@thingsboard" />
<meta name="twitter:creator" content="@thingsboard" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "WebPage",
    "headline": "Thingsboard Data Collection Performance",
    "image": "http://localhost:4000/images/thingsboard_logo.png",
    "description": "Thingsboard IoT Platform data collection performance overview",
    "logo": "http://localhost:4000/images/thingsboard_logo.png",
    "url": "http://localhost:4000/docs/reference/performance/"
  }
</script>
<!-- End Jekyll SEO tag -->
	
	
	<link rel="shortcut icon" type="image/png" href="/images/favicon.png">

	<link rel="stylesheet" href="/css/styles.css">
	<script type="text/javascript">
		/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
		!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);
		/*! onloadCSS. (onload callback for loadCSS) [c]2017 Filament Group, Inc. MIT License */
		function onloadCSS(a,b){function c(){!d&&b&&(d=!0,b.call(a))}var d;a.addEventListener&&a.addEventListener("load",c),a.attachEvent&&a.attachEvent("onload",c),"isApplicationInstalled"in navigator&&"onloadcssdefined"in a&&a.onloadcssdefined(c)}
	</script>
	<script type="text/javascript">

		function jqueryDefer(method) {
			if (window.jQuery) {
				method();
			} else {
				setTimeout(function() {
					jqueryDefer(method)
				}, 50);
			}
		}

		function jqueryUiDefer(method) {
			if (window.jQuery && window.jQuery.ui) {
				method();
			} else {
				setTimeout(function() {
					jqueryUiDefer(method)
				}, 50);
			}
		}

		function loadScript(src, callback)
		{
			var s, r, t;
			r = false;
			s = document.createElement('script');
			s.type = 'text/javascript';
			s.src = src;
			s.onload = s.onreadystatechange = function() {
				if ( !r && (!this.readyState || this.readyState == 'complete') )
				{
					r = true;
					if (callback) {
						callback();
					}
				}
			};
			t = document.getElementsByTagName('script')[0];
			t.parentNode.insertBefore(s, t);
		}

		function loadCssAsync(src, callback) {
			var stylesheet = loadCSS( src );
			if (callback) {
				onloadCSS(stylesheet, callback);
			}
		}

		function loadNextScript(index, scriptsList, completeCallback) {
			if (index < scriptsList.length) {
				var script = scriptsList[index];
				if (script.type === 'script') {
					loadScript(script.src, function() {
						index++;
						loadNextScript(index, scriptsList, completeCallback);
					});
				} else if (script.type === 'css') {
					loadCssAsync(script.src, function() {
						index++;
						loadNextScript(index, scriptsList, completeCallback);
					});
				}
			} else if (completeCallback) {
				completeCallback();
			}
		}

		var initialScriptsList = [
			{src: '/js/jquery-2.2.0.min.js', type: 'script'},
			{src: '/css/jquery-ui.min.css', type: 'css'},
			{src: '/js/jquery-ui.min.js', type: 'script'},
			{src: '/js/script.js', type: 'script'},
			{src: '/css/sweetalert.css', type: 'css'},
			{src: '/js/sweetalert.min.js', type: 'script'}
		];

		loadNextScript(0, initialScriptsList);

	</script>
	<script type="text/javascript">
		function _gaLt(event) {
			/* If GA is blocked or not loaded, or not main|middle|touch click then don't track */
			if (!ga.hasOwnProperty("loaded") || ga.loaded != true || (event.which != 1 && event.which != 2)) {
				return;
			}
			var el = event.srcElement || event.target;

			while (el && (typeof el.tagName == 'undefined' || el.tagName.toLowerCase() != 'a' || !el.href)) {
				el = el.parentNode;
			}
			if (el && el.href) {
				var link = el.href;
				if ((link.indexOf(location.host) == -1 || link.indexOf('.' + location.host) > 0) && !link.match(/^javascript\:/i)) {
					var target = (el.target && !el.target.match(/^_(self|parent|top)$/i)) ? el.target : false;
					if (event.ctrlKey || event.shiftKey || event.metaKey || event.which == 2) {
						target = "_blank";
					}

					var hbrun = false; // tracker has not yet run
					var hitBack = function() {
						if (hbrun) return;
						hbrun = true;
						window.location.href = link;
					};

					if (target) {
						ga(
								"send", "event", "Outgoing Links", link,
								document.location.pathname + document.location.search
						);
					} else {
						event.preventDefault ? event.preventDefault() : event.returnValue = !1;
						ga(
								"send", "event", "Outgoing Links", link,
								document.location.pathname + document.location.search, {
									"hitCallback": hitBack
								}
						);

						setTimeout(hitBack, 1000);
					}
				}
			}
		}

		var _w = window;
		var _gaLtEvt = ("ontouchstart" in _w) ? "click" : "mousedown";
		_w.addEventListener ? _w.addEventListener("load", function() {document.body.addEventListener(_gaLtEvt, _gaLt, !1)}, !1)
				: _w.attachEvent && _w.attachEvent("onload", function() {document.body.attachEvent("on" + _gaLtEvt, _gaLt)});
	</script>
</head>
<body>
<div id="cellophane" onclick="tb.toggleMenu()"></div>
<header>
	<a href="#" class="logo"></a>
	<div class="nav-buttons" data-auto-burger="primary">
		<a href="#" class="button" id="viewDocs" data-auto-burger-exclude>&nbsp;&nbsp;主要功能&nbsp;&nbsp;</a>
		<a href="#" class="button" id="useCases" data-auto-burger-exclude>&nbsp;&nbsp;查看文档&nbsp;&nbsp;</a>
		<a href="#" class="button" id="useCases" data-auto-burger-exclude>&nbsp;&nbsp;案例分析&nbsp;&nbsp;</a>
		<a href="#" class="button" id="gettingStarted" data-auto-burger-exclude>&nbsp;&nbsp;开始使用&nbsp;&nbsp;</a>
		<button id="hamburger" onclick="tb.toggleMenu()" data-auto-burger-exclude><div></div></button>
	</div>

	<nav id="mainNav">
		<main id="headNav" data-auto-burger="primary">
			<div class="nav-box">
				<h3><a href="#">开始使用<a></h3>
			</div>
			<div class="nav-box">
				<h3><a href="#">查看文档</a></h3>
			</div>
			<div class="nav-box">
				<h3><a href="#">案例分析</a></h3>
			</div>
			<div class="nav-box">
				<h3><a href="http://osswangxining.github.io/">Blog</a></h3>
			</div>
			<div class="nav-box">
				<h3><a href="#">服务支持</a></h3>
			</div>
			<div class="nav-box">
				<h3><a href="#">联系我们</a></h3>
			</div>
		</main>

	</nav>
</header>


<!--  HERO  -->
<section id="hero" class="light-text">
  <h1>Reference Documentation</h1>
  <h5>Design docs, concept definitions, and references for APIs and CLIs.</h5>
  <div id="vendorStrip" class="light-text">
    <div id="docsList">
        <ul>
          <li><a href="/docs/" >DOCS HOME</a></li>
          <li><a href="/docs/api/" >API</a></li>
          <li><a href="/docs/iot-gateway/" >IOT GATEWAY</a></li>
          <li><a href="/docs/reference/" class="YAH">REFERENCE</a></li>
          <li><a href="/docs/samples/" >SAMPLES</a></li>
          <li><a href="/iot-use-cases/" >USE CASES</a></li>
          <li><a href="/docs/iot-video-tutorials/" >VIDEO TUTORIALS</a></li>
          <li><a href="/docs/faq/" >FAQ</a></li>
          <li><a href="/docs/services/" >SERVICES</a></li>
          <li><a href="/docs/contact-us/" >CONTACT US</a></li>
        </ul>
    </div>
    <div id="searchBox">
      <input type="text" id="search" placeholder="Search" onkeydown="if (event.keyCode==13) window.location.replace('/docs/search/?q=' + this.value)">
    </div>
  </div>
</section>





<section id="encyclopedia">
  
  <div id="docsToc" >
        <div class="pi-accordion">
        
    <a class="item" data-title="Reference Documentation" href="/docs/reference/"></a>
    <a class="item" data-title="Thingsboard Architecture" href="/docs/reference/architecture/"></a>
<div class="item" data-title="Thingsboard Performance">
  <div class="container">
    <a class="item" data-title="Data Collection Performance" href="/docs/reference/performance/"></a>
    <a class="item" data-title="Performance Test Tools" href="/docs/reference/performance-tools/"></a>
    <a class="item" data-title="How to repeate the tests" href="/docs/reference/performance-tests/"></a>
  </div>
</div>
<div class="item" data-title="Rule Engine components">
  <div class="container">
<div class="item" data-title="Filters">
  <div class="container">
    <a class="item" data-title="Message Type Filter" href="/docs/reference/filters/message-type-filter/"></a>
    <a class="item" data-title="Device Attributes Filter" href="/docs/reference/filters/device-attributes-filter/"></a>
    <a class="item" data-title="Device Telemetry Filter" href="/docs/reference/filters/device-telemetry-filter/"></a>
    <a class="item" data-title="Method Name Filter" href="/docs/reference/filters/method-name-filter/"></a>
  </div>
</div>
<div class="item" data-title="Processors">
  <div class="container">
    <a class="item" data-title="Alarm Deduplication Processor" href="/docs/reference/processors/alarm-deduplication-processor/"></a>
  </div>
</div>
<div class="item" data-title="Actions">
  <div class="container">
    <a class="item" data-title="Telemetry Plugin Action" href="/docs/reference/actions/telemetry-plugin-action/"></a>
    <a class="item" data-title="Send Mail Action" href="/docs/reference/actions/send-mail-action/"></a>
    <a class="item" data-title="Kafka Plugin Action" href="/docs/reference/actions/kafka-plugin-action/"></a>
    <a class="item" data-title="RabbitMQ Plugin Action" href="/docs/reference/actions/rabbitmq-plugin-action/"></a>
    <a class="item" data-title="REST API Call Plugin Action" href="/docs/reference/actions/rest-api-call-plugin-action/"></a>
    <a class="item" data-title="RPC Plugin Action" href="/docs/reference/actions/rpc-plugin-action/"></a>
  </div>
</div>
<div class="item" data-title="Plugins">
  <div class="container">
    <a class="item" data-title="Telemetry Plugin" href="/docs/reference/plugins/telemetry/"></a>
    <a class="item" data-title="RPC Plugin" href="/docs/reference/plugins/rpc/"></a>
    <a class="item" data-title="Device Messaging Plugin" href="/docs/reference/plugins/messaging/"></a>
    <a class="item" data-title="Mail Plugin" href="/docs/reference/plugins/mail/"></a>
    <a class="item" data-title="Kafka Plugin" href="/docs/reference/plugins/kafka/"></a>
    <a class="item" data-title="RabbitMQ Plugin" href="/docs/reference/plugins/rabbitmq/"></a>
    <a class="item" data-title="REST API Call Plugin" href="/docs/reference/plugins/rest/"></a>
    <a class="item" data-title="Time RPC Plugin" href="/docs/reference/plugins/time/"></a>
  </div>
</div>
  </div>
</div>
    <a class="item" data-title="Release Notes" href="https://github.com/thingsboard/thingsboard/releases/" target='_blank'></a>
        </div> <!-- /pi-accordion -->
    <button class="push-menu-close-button" onclick="tb.toggleToc()"></button>
  </div> <!-- /docsToc -->
  
  <div id="docsContent" class="">
    <h1>Thingsboard Data Collection Performance</h1>
    <ul id="markdown-toc">
  <li><a href="#architecture" id="markdown-toc-architecture">Architecture</a></li>
  <li><a href="#data-flow-and-test-tools" id="markdown-toc-data-flow-and-test-tools">Data flow and test tools</a></li>
  <li><a href="#performance-improvement-steps" id="markdown-toc-performance-improvement-steps">Performance improvement steps</a>    <ul>
      <li><a href="#step-1-asynchronous-cassandra-driver-api" id="markdown-toc-step-1-asynchronous-cassandra-driver-api">Step 1. Asynchronous Cassandra Driver API</a></li>
      <li><a href="#step-2-connection-pooling" id="markdown-toc-step-2-connection-pooling">Step 2. Connection pooling</a></li>
      <li><a href="#step-3-vertical-scaling" id="markdown-toc-step-3-vertical-scaling">Step 3: Vertical scaling</a></li>
      <li><a href="#step-4-horizontal-scaling" id="markdown-toc-step-4-horizontal-scaling">Step 4: Horizontal scaling</a></li>
    </ul>
  </li>
  <li><a href="#how-to-repeat-the-tests" id="markdown-toc-how-to-repeat-the-tests">How to repeat the tests</a></li>
  <li><a href="#conclusion" id="markdown-toc-conclusion">Conclusion</a></li>
</ul>

<p>One of the key features of Thingsboard open-source IoT Platform is data collection and this is crucial feature that must work reliable under high load. 
In this article we are going to describe steps and improvements that we have made to ensure that single instance of Thingsboard server 
can constantly handle <strong>20,000+</strong> devices and <strong>30,000+</strong> MQTT publish messages per second,
which in summary gives us around <strong>2 million published messages per minute</strong>.</p>

<h2 id="architecture">Architecture</h2>

<p>Thingsboard performance leverages three main projects:</p>

<ul>
  <li><a href="http://netty.io/">Netty</a> for high performance MQTT server/broker for IoT devices.</li>
  <li><a href="http://akka.io/">Akka</a> for high performance actor system to coordinate messages between millions of devices.</li>
  <li><a href="http://cassandra.apache.org/">Cassandra</a> for scalable high-performance NoSQL DB to store timeseries data from devices.</li>
</ul>

<p>We also use <a href="https://zookeeper.apache.org/">Zookeeper</a> for coordination and <a href="http://www.grpc.io/">gRPC</a> in cluster mode. See <a href="/docs/reference/architecture">platform architecture</a> for more details.</p>

<h2 id="data-flow-and-test-tools">Data flow and test tools</h2>

<p>IoT devices connect to Thingsboard server via MQTT and issue “publish” commands with JSON payload. 
Size of single publish message is approximately 100 bytes. 
<a href="http://mqtt.org/">MQTT</a> is light-weight publish/subscribe messaging protocol and offers number of advantages over HTTP request/response protocol.</p>

<p><img src="/images/reference/performance/performance-diagram-0.svg" alt="image" /></p>

<p>Thingsboard server processes MQTT publish messages and stores them to Cassandra asynchronously.
Server may also push data to websocket subscriptions from the Web UI dashboards (if present).
We try to avoid any blocking operations and this is critical for overall system performance.
Thingsboard supports MQTT QoS level 1, which means that client receives response to the publish message only after data is stored to Cassandra DB.
Data duplicates which are possible with QoS level 1 are just overwrites to corresponding Cassandra row and thus are not present in persisted data. 
This functionality provides reliable data delivery and persistence.</p>

<p>We have used <a href="http://gatling.io/">Gatling</a> load testing framework that is also based on Akka and Netty. 
Gatling is able to simulate 10K MQTT clients using 5-10% of a 2-core CPU. 
See our separate <a href="/docs/reference/performance-tools">article</a> about how we improved unofficial Gatling MQTT plugin to support our use case.</p>

<h2 id="performance-improvement-steps">Performance improvement steps</h2>

<h3 id="step-1-asynchronous-cassandra-driver-api">Step 1. Asynchronous Cassandra Driver API</h3>

<p>The results of first performance tests on the modern 4-core laptop with SSD was quite poor. Platform was able to process only 200 messages per second.
The root cause and main performance bottle-neck was quite obvious and easy to find. 
It appears that the processing was not 100% asynchronous and we were executing blocking API call of Cassandra driver inside the <a href="/docs/user-guide/telemetry/">Telemetry plugin</a> actor.
Quick refactoring of the plugin implementation resulted in more then 10X performance improvement and we received approximately 2500 published messages per second from 1000 devices.
We would like to recommend <a href="http://www.datastax.com/dev/blog/java-driver-async-queries">this article</a> about async queries to Cassandra.</p>

<h3 id="step-2-connection-pooling">Step 2. Connection pooling</h3>

<p>We have decided to move to AWS EC2 instances to be able to share both results and tests we executed. We start running tests on <a href="http://www.ec2instances.info/?selected=c4.xlarge">c4.xlarge</a> instance (4 vCPUs and 7.5 Gb of RAM) with Cassandra and Thingsboard services co-located.</p>

<p><img src="/images/reference/performance/performance-diagram-1.svg" alt="image" /></p>

<p>Test specification:</p>

<ul>
  <li>Number of devices: 10 000</li>
  <li>Publish frequency per device: once per second</li>
  <li>Total load: 10 000 messages per second</li>
</ul>

<p>First test results were obviously unacceptable:</p>

<p><img src="/images/reference/performance/single_node_no_fix_stats.png" alt="image" /></p>

<p>The huge response time above was caused by the fact that server simply not able to process 10 K messages per second and they are getting queued.</p>

<p>We have started our investigation with monitoring memory and CPU load on the testing instance. 
Initially our guessing regarding poor performance was because of the heavy load on CPU or RAM. 
But in fact during load testing we have seen that CPU in particular moments was idle for a couple of seconds. 
This ‘pause’ event was happening every 3-7 seconds, see chart below.</p>

<p><img src="/images/reference/performance/single_node_no_fix_rps.png" alt="image" /></p>

<p>As next step we have decided to do the thread dump during these pauses. 
We were expecting to see threads that are blocked and this could give us some clue what is happening while pauses. 
So we have opened separate console to monitor CPU load and another one to execute thread dump while performing stress tests using the following command:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>
<span class="nb">kill</span> -3 THINGSBOARD_PID

</code></pre>
</div>

<p>We have identified that during pause there was always one thread in TIMED_WAITING state and the root cause was in method awaitAvailableConnection of Cassandra driver:</p>

<div class="language-bash highlighter-rouge"><pre class="highlight"><code>java.lang.Thread.State: TIMED_WAITING <span class="o">(</span>parking<span class="o">)</span>
at sun.misc.Unsafe.park<span class="o">(</span>Native Method<span class="o">)</span>
parking to <span class="nb">wait </span><span class="k">for</span>  &lt;0x0000000092d9d390&gt; <span class="o">(</span>a java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="nv">$ConditionObject</span><span class="o">)</span>
at java.util.concurrent.locks.LockSupport.parkNanos<span class="o">(</span>LockSupport.java:215<span class="o">)</span>
at java.util.concurrent.locks.AbstractQueuedSynchronizer<span class="nv">$ConditionObject</span>.await<span class="o">(</span>AbstractQueuedSynchronizer.java:2163<span class="o">)</span>
at com.datastax.driver.core.HostConnectionPool.awaitAvailableConnection<span class="o">(</span>HostConnectionPool.java:287<span class="o">)</span>
at com.datastax.driver.core.HostConnectionPool.waitForConnection<span class="o">(</span>HostConnectionPool.java:328<span class="o">)</span>
at com.datastax.driver.core.HostConnectionPool.borrowConnection<span class="o">(</span>HostConnectionPool.java:251<span class="o">)</span>
at com.datastax.driver.core.RequestHandler<span class="nv">$SpeculativeExecution</span>.query<span class="o">(</span>RequestHandler.java:301<span class="o">)</span>
at com.datastax.driver.core.RequestHandler<span class="nv">$SpeculativeExecution</span>.sendRequest<span class="o">(</span>RequestHandler.java:281<span class="o">)</span>
at com.datastax.driver.core.RequestHandler.startNewExecution<span class="o">(</span>RequestHandler.java:115<span class="o">)</span>
at com.datastax.driver.core.RequestHandler.sendRequest<span class="o">(</span>RequestHandler.java:91<span class="o">)</span>
at com.datastax.driver.core.SessionManager.executeAsync<span class="o">(</span>SessionManager.java:132<span class="o">)</span>
at org.thingsboard.server.dao.AbstractDao.executeAsync<span class="o">(</span>AbstractDao.java:91<span class="o">)</span>
at org.thingsboard.server.dao.AbstractDao.executeAsyncWrite<span class="o">(</span>AbstractDao.java:75<span class="o">)</span>
at org.thingsboard.server.dao.timeseries.BaseTimeseriesDao.savePartition<span class="o">(</span>BaseTimeseriesDao.java:135<span class="o">)</span>
</code></pre>
</div>

<p>As a result we have realized that default connection pool configuration for cassandra driver caused bad results in our use case.</p>

<p><a href="http://docs.datastax.com/en/developer/java-driver/2.1/manual/pooling/">Official configuration</a> for connection pool feature contains special option 
<strong>‘Simultaneous requests per connection’</strong> that allows you to tune concurrent request per single connection. 
We use cassandra driver protocol v3 and by default it uses next values:</p>

<ul>
  <li>1024 for LOCAL hosts.</li>
  <li>256 for REMOTE hosts.</li>
</ul>

<p>Considering the fact that we are actually pulling data from 10,000 devices, default values are definitely not enough. 
So we have done changes in the code and updated values for LOCAL and REMOTE hosts and set them to the maximum possible values:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">poolingOptions</span>
    <span class="o">.</span><span class="na">setMaxRequestsPerConnection</span><span class="o">(</span><span class="n">HostDistance</span><span class="o">.</span><span class="na">LOCAL</span><span class="o">,</span> <span class="mi">32768</span><span class="o">)</span>
    <span class="o">.</span><span class="na">setMaxRequestsPerConnection</span><span class="o">(</span><span class="n">HostDistance</span><span class="o">.</span><span class="na">REMOTE</span><span class="o">,</span> <span class="mi">32768</span><span class="o">);</span>
</code></pre>
</div>

<p>Test results after the applied changes are listed below.</p>

<p><img src="/images/reference/performance/single_node_with_fix_stats.png" alt="image" /></p>

<p><img src="/images/reference/performance/single_node_with_fix_rps.png" alt="image" /></p>

<p>The results were much better, but far from even 1 million messages per minute. We have not seen pauses in CPU load during our tests on c4.xlarge any more.
CPU load was high (80-95%) during entire test. We have done couple thread dumps to verify that cassandra driver does not awaiting available connections 
and indeed we have not seen this issue anymore.</p>

<h3 id="step-3-vertical-scaling">Step 3: Vertical scaling</h3>

<p>We have decided to run the same tests on twice more powerful node <a href="http://www.ec2instances.info/?selected=c4.2xlarge">c4.2xlarge</a> with 8 vCPUs and 15Gb of RAM.
The performance increase was not linear and the CPU was still loaded (80-90%).</p>

<p><img src="/images/reference/performance/single_node_x2_with_fix_stats.png" alt="image" /></p>

<p>We have noticed significant improvement in response time. After significant peak on the start of the test maximum response time was within 200ms and average response time was ~ 50ms.</p>

<p><img src="/images/reference/performance/single_node_x2_with_fix_time.png" alt="image" /></p>

<p>Number of requests per second was around 10K</p>

<p><img src="/images/reference/performance/single_node_x2_with_fix_rps.png" alt="image" /></p>

<p>We have also executed test on <a href="http://www.ec2instances.info/?selected=c4.4xlarge">c4.4xlarge</a> with 16 vCPUs and 30Gb of RAM but have not noticed significant improvements and decided to separate Thingsboard server and move Cassandra to three nodes cluster.</p>

<h3 id="step-4-horizontal-scaling">Step 4: Horizontal scaling</h3>

<p>Our main goal was to identify how much MQTT messages we can handle using single Thingsboard server running on <a href="http://www.ec2instances.info/?selected=c4.2xlarge">c4.2xlarge</a>.
We will cover horizontal scalability of Thingsboard cluster in a separate article. 
So, we decided to move Cassandra to three <a href="http://www.ec2instances.info/?selected=c4.xlarge">c4.xlarge</a> separate instances with default configuration 
and launch gatling stress test tool from two separate <a href="http://www.ec2instances.info/?selected=c4.xlarge">c4.xlarge</a> instances simultaneously 
to minimize possible affect on latency and throughput by thirdparty.</p>

<p><img src="/images/reference/performance/performance-diagram-2.svg" alt="image" /></p>

<p>Test specification:</p>

<ul>
  <li>Number of devices: 20 000</li>
  <li>Publish frequency per device: twice per second</li>
  <li>Total load: 40 000 messages per second</li>
</ul>

<p>The statistics of two simultaneous test runs launched on different client machines is listed below.</p>

<p><img src="/images/reference/performance/cluster_stats.png" alt="image" />
<img src="/images/reference/performance/cluster_rps.png" alt="image" />
<img src="/images/reference/performance/cluster_responses_ps.png" alt="image" /></p>

<p>Based on the data from two simultaneous test runs we have reached <strong>30 000 published messages per second</strong> which is equal to <strong>1.8 million per minute</strong>.</p>

<h2 id="how-to-repeat-the-tests">How to repeat the tests</h2>

<p>We have prepared several AWS AMIs for anyone who is interested in replication of these tests. See separate <a href="/docs/reference/performance-tests">documentation page</a> with detailed instructions.</p>

<h2 id="conclusion">Conclusion</h2>

<p>This performance test demonstrates how small Thingsboard cluster, that cost approximately <strong>1$ per hour</strong>, can easily receive,
store and visualize more than <strong>100 million messages</strong> from your devices. 
We will continue our work on performance improvements and going to publish performance results for cluster of Thingsboard servers in our next blog post. <br />
We hope this article will be useful for people who are evaluating the platform and want to execute performance tests on their own.
We also hope that performance improvement steps will be useful for any engineers who use similar technologies.</p>

<p>Please let us know your feedback and follow our project on <a href="https://github.com/thingsboard/thingsboard"><strong>Github</strong></a> or <a href="https://twitter.com/thingsboard"><strong>Twitter</strong></a>.</p>

  </div>
</section>

<footer>
	<main class="light-text">
		
		<div id="miceType" class="center">&copy; 2016 - 2017 IoT套件</div>
	</main>

</footer>



<button class="flyout-button" onclick="tb.toggleToc()"></button>


<style>
  .cse .gsc-control-cse, .gsc-control-cse {
    padding: 0;
  }
  .gsc-control-cse table, .gsc-control-cse-en table {
    margin:0px !important;
  }
  .gsc-above-wrapper-area {
    border-bottom: 0;
  }
</style>
</body>
</html>
